import subprocess
import requests
import re
from pathlib import Path
from typing import Dict, Optional, List, Tuple
import logging
from ..config import settings
from .git_utils import extract_function_signatures, extract_function

logger = logging.getLogger(__name__)

class GitManager:
    def __init__(self, repo_paths: Dict[str, Path] = None):
        self.repo_paths = repo_paths or settings.REPO_PATHS
        self.github_urls = settings.GITHUB_URLS

    def get_file_content(self, project: str, commit_hash: str, 
                        file_path: str, parent: bool = False) -> Optional[str]:
        """Get file content at specific commit."""
        try:
            if parent:
                commit_hash = f"{commit_hash}^"
                
            repo_path = self.repo_paths[project]
            command = ["git", "show", f"{commit_hash}:{file_path}"]
            result = subprocess.run(
                command,
                cwd=repo_path,
                text=True,
                capture_output=True,
                check=True,
                encoding='utf-8',
                errors='ignore'
            )
            return result.stdout
        except Exception as e:
            logger.error(f"Error getting file {file_path} at {commit_hash} in {project}: {e}")
            return None

    def get_patch(self, project: str, commit_hash: str) -> Optional[str]:
        """Get patch for specific commit."""
        try:
            # Try GitHub API first
            url = f"{self.github_urls[project]}/commit/{commit_hash}.patch"
            try:
                response = requests.get(url)
                response.raise_for_status()
                return response.text
            except requests.RequestException:
                # Fall back to local git
                repo_path = self.repo_paths[project]
                result = subprocess.run(
                    ["git", "show", commit_hash],
                    cwd=repo_path,
                    text=True,
                    capture_output=True,
                    check=True,
                    encoding='utf-8',
                    errors='ignore'
                )
                return result.stdout
        except Exception as e:
            logger.error(f"Error getting patch for {commit_hash} in {project}: {e}")
            return None

    def analyze_patch(self, patch_text: str) -> Dict:
        """Analyze patch content and extract metrics."""
        if not patch_text:
            return {}

        files_changed = set()
        lines_added = 0
        lines_deleted = 0
        functions_changed = set()

        file_pattern = re.compile(r'^diff --git a/(.*?) b/')
        function_pattern = re.compile(r'^@@.*?@@ .*?(\w+\s+\w+\s*\()')

        current_file = None
        for line in patch_text.split('\n'):
            # Track files
            file_match = file_pattern.search(line)
            if file_match:
                current_file = file_match.group(1)
                files_changed.add(current_file)
                continue

            # Track functions
            func_match = function_pattern.search(line)
            if func_match:
                functions_changed.add(func_match.group(1).strip())
                continue

            # Track line changes
            if line.startswith('+') and not line.startswith('+++'):
                lines_added += 1
            elif line.startswith('-') and not line.startswith('---'):
                lines_deleted += 1

        return {
            'files_changed': len(files_changed),
            'functions_changed': len(functions_changed),
            'lines_added': lines_added,
            'lines_deleted': lines_deleted,
            'files': files_changed,
            'functions': functions_changed
        }

    def extract_vulnerable_code(self, project: str, commit_hash: str, 
                              file_path: str) -> Optional[str]:
        """Extract vulnerable code (pre-fix)."""
        return self.get_file_content(project, commit_hash, file_path, parent=True)

    def extract_patched_code(self, project: str, commit_hash: str,
                           file_path: str) -> Optional[str]:
        """Extract patched code (post-fix)."""
        return self.get_file_content(project, commit_hash, file_path)

    def get_commit_description(self, project: str, commit_hash: str) -> Optional[str]:
        """Get commit description."""
        try:
            repo_path = self.repo_paths[project]
            result = subprocess.run(
                ['git', 'log', '--format=%B', '-n', '1', commit_hash],
                cwd=repo_path,
                stdout=subprocess.PIPE,
                text=True,
                encoding='utf-8'
            )
            return result.stdout.strip()
        except Exception as e:
            logger.error(f"Error getting description for {commit_hash}: {e}")
            return None