import sqlite3
import logging
import platform
import os
from pathlib import Path
from typing import Optional, List
import re

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class FunctionCounter:
    def __init__(self):
        """Initialize function counter with Clang support for Mozilla."""
        self.use_clang = False
        try:
            import clang.cindex
            from clang.cindex import Config, CursorKind
            
            # Set up libclang based on platform
            if platform.system() == "Darwin":
                if os.path.exists("/Applications/Xcode.app"):
                    Config.set_library_file("/Applications/Xcode.app/Contents/Frameworks/libclang.dylib")
                    self.use_clang = True
            else:
                # Try common Linux paths
                possible_paths = [
                    "/usr/lib/llvm-11/lib/libclang.so",
                    "/usr/lib/libclang.so",
                    "/usr/lib/llvm/lib/libclang.so"
                ]
                for path in possible_paths:
                    if os.path.exists(path):
                        Config.set_library_file(path)
                        self.use_clang = True
                        break
            
            if self.use_clang:
                self.clang = clang.cindex
                self.index = self.clang.Index.create()
                logger.info("Clang-based function counting enabled")
            
        except Exception as e:
            logger.warning(f"Failed to initialize Clang: {e}")
            self.use_clang = False

    def count_functions_clang(self, code: str) -> int:
        """Count functions using Clang parser."""
        if not code or not self.use_clang:
            return 0
            
        try:
            # Create temporary file for Clang parsing
            import tempfile
            with tempfile.NamedTemporaryFile(suffix='.cpp', mode='w') as temp_file:
                temp_file.write(code)
                temp_file.flush()
                
                # Parse with Clang
                args = ['-x', 'c++', '--std=c++11']
                tu = self.index.parse(temp_file.name, args=args)
                
                if not tu:
                    logger.error("Failed to parse code with Clang")
                    return 0

                # Count function definitions
                function_count = 0
                for cursor in tu.cursor.walk_preorder():
                    if cursor.kind in [self.clang.CursorKind.FUNCTION_DECL,
                                     self.clang.CursorKind.CXX_METHOD,
                                     self.clang.CursorKind.CONSTRUCTOR,
                                     self.clang.CursorKind.DESTRUCTOR]:
                        if cursor.is_definition():
                            function_count += 1
                
                return function_count
                
        except Exception as e:
            logger.error(f"Error in Clang parsing: {e}")
            return 0

    def count_functions_regex(self, code: str) -> int:
        """Count functions using regex patterns."""
        if not code:
            return 0
            
        # Pattern for C/C++ function definitions
        patterns = [
            # Standard function definition
            r'(?:[\w\*&]+\s+)+\w+\s*\([^)]*\)\s*{',
            # Constructor/destructor
            r'(?:~?\w+)\s*\([^)]*\)\s*(?::\s*\w+\([^)]*\)\s*)*{',
            # Function with attributes
            r'__attribute__\s*\(\([^)]*\)\)\s*(?:[\w\*&]+\s+)+\w+\s*\([^)]*\)\s*{'
        ]
        
        function_count = 0
        for pattern in patterns:
            matches = re.finditer(pattern, code)
            function_count += sum(1 for _ in matches)
            
        return function_count

    def count_functions(self, code: str, project: str) -> int:
        """Count functions using appropriate method based on project."""
        if not code:
            return 0
            
        if project.lower() == 'mozilla' and self.use_clang:
            return self.count_functions_clang(code)
        else:
            return self.count_functions_regex(code)

def update_function_counts():
    """Update NUM_FUNCTIONS_CHANGED in vulnerabilities table."""
    db_path = "vulnerability_dataset/database/database.sqlite"
    counter = FunctionCounter()
    
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # First, reset all NUM_FUNCTIONS_CHANGED values to NULL
        logger.info("Resetting existing function counts...")
        cursor.execute("UPDATE vulnerabilities SET NUM_FUNCTIONS_CHANGED = NULL")
        conn.commit()
        
        # Get all rows that need updating
        cursor.execute("""
            SELECT id, PROJECT, VULNERABLE_CODE_BLOCK, PATCHED_CODE_BLOCK 
            FROM vulnerabilities 
            WHERE NUM_FUNCTIONS_CHANGED IS NULL
            AND VULNERABLE_CODE_BLOCK IS NOT NULL
            AND PATCHED_CODE_BLOCK IS NOT NULL
        """)
        rows = cursor.fetchall()
        
        logger.info(f"Found {len(rows)} rows to update")
        
        for row in rows:
            row_id, project, vuln_code, patched_code = row
            
            # Count functions in both versions
            vuln_count = counter.count_functions(vuln_code, project)
            patched_count = counter.count_functions(patched_code, project)
            
            # Use max of the two counts
            function_count = max(vuln_count, patched_count)
            
            # Update the database
            cursor.execute("""
                UPDATE vulnerabilities 
                SET NUM_FUNCTIONS_CHANGED = ? 
                WHERE id = ?
            """, (function_count, row_id))
            
            logger.info(f"Updated row {row_id} with {function_count} functions")
        
        conn.commit()
        logger.info("Successfully updated all function counts")
        
    except Exception as e:
        logger.error(f"Error updating function counts: {e}")
        if 'conn' in locals():
            conn.rollback()
    finally:
        if 'conn' in locals():
            conn.close()

if __name__ == "__main__":
    update_function_counts()
