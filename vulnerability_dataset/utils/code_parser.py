from typing import Optional, Tuple, List
import platform
import logging
import os
import subprocess
import tempfile
import re
from pathlib import Path

logger = logging.getLogger(__name__)

class CodeParser:
    def __init__(self):
        """Initialize the Clang-based code parser."""
        self.use_clang = False
        try:
            import clang.cindex
            from clang.cindex import Config, CursorKind
            
            # Try to set up libclang
            if platform.system() == "Darwin":
                if os.path.exists("/Applications/Xcode.app"):
                    Config.set_library_file("/Applications/Xcode.app/Contents/Frameworks/libclang.dylib")
                    self.use_clang = True
                elif os.path.exists("/usr/local/opt/llvm/lib/libclang.dylib"):
                    Config.set_library_file("/usr/local/opt/llvm/lib/libclang.dylib")
                    self.use_clang = True
            else:
                # Try to find libclang on Linux
                try:
                    # Try to get libclang path from llvm-config
                    result = subprocess.run(['llvm-config', '--libdir'], 
                                         capture_output=True, text=True)
                    if result.returncode == 0:
                        libdir = result.stdout.strip()
                        libclang = Path(libdir) / 'libclang.so'
                        if libclang.exists():
                            Config.set_library_file(str(libclang))
                            self.use_clang = True
                except:
                    # Fallback to common paths
                    common_paths = [
                        '/usr/lib/llvm*/lib/libclang.so',
                        '/usr/lib/x86_64-linux-gnu/libclang-*.so',
                        '/usr/lib64/libclang.so'
                    ]
                    for pattern in common_paths:
                        matches = list(Path('/').glob(pattern.lstrip('/')))
                        if matches:
                            Config.set_library_file(str(matches[-1]))  # Use latest version
                            self.use_clang = True
                            break

            if self.use_clang:
                self.clang = clang.cindex
                self.index = self.clang.Index.create()
                self.cursor_kind = CursorKind
                logger.info("Using Clang-based parsing")
            else:
                logger.warning("Libclang not found, using regex-based parsing")
                
        except Exception as e:
            logger.warning(f"Failed to initialize Clang: {e}")
            self.use_clang = False

    def find_function_boundaries(self, code: str, line_number: int) -> Optional[Tuple[int, int]]:
        """Find the start and end lines of a function containing the given line number."""
        if not self.use_clang:
            return self._find_function_boundaries_regex(code, line_number)
            
        try:
            with tempfile.NamedTemporaryFile(suffix='.cpp', mode='w') as temp_file:
                temp_file.write(code)
                temp_file.flush()
                
                # Parse with Clang
                args = ['-x', 'c++', '--std=c++11']  # C++ parsing flags
                tu = self.index.parse(temp_file.name, args=args)
                
                if not tu:
                    logger.error("Failed to parse code with Clang")
                    return self._find_function_boundaries_regex(code, line_number)

                # Find function containing line_number
                for cursor in tu.cursor.walk_preorder():
                    if cursor.kind in [self.cursor_kind.FUNCTION_DECL,
                                     self.cursor_kind.CXX_METHOD,
                                     self.cursor_kind.CONSTRUCTOR,
                                     self.cursor_kind.DESTRUCTOR]:
                        start = cursor.extent.start.line
                        end = cursor.extent.end.line
                        
                        if start <= line_number <= end:
                            return start, end

        except Exception as e:
            logger.error(f"Error in Clang parsing: {e}")
            return self._find_function_boundaries_regex(code, line_number)

        return None

    def _find_function_boundaries_regex(self, code: str, line_number: int) -> Optional[Tuple[int, int]]:
        """Fallback regex-based function boundary detection."""
        lines = code.split('\n')
        if line_number < 1 or line_number > len(lines):
            return None
            
        # Improved regex for function definition
        func_pattern = re.compile(
            r'^(?:\s*(?:virtual|static|inline|extern)\s+)*'  # Optional modifiers
            r'(?:[\w:~<>]+\s+)*'  # Return type with templates
            r'[\w:~]+\s*'  # Function name
            r'<[^>]*>?\s*'  # Optional template parameters
            r'\([^)]*\)\s*'  # Parameters
            r'(?:const|noexcept|override|final)?\s*'  # Optional specifiers
            r'(?:try\s*)?\{'  # Opening brace
        )
        
        # Find function start
        start_line = None
        for i in range(line_number - 1, -1, -1):
            if func_pattern.match(lines[i].strip()):
                start_line = i + 1
                break
                
        if start_line is None:
            return None
            
        # Find function end by matching braces
        brace_count = 1
        end_line = None
        
        for i in range(start_line, len(lines)):
            line = lines[i]
            brace_count += line.count('{')
            brace_count -= line.count('}')
            if brace_count == 0:
                end_line = i + 1
                break
                
        if end_line is None:
            return None
            
        return start_line, end_line

    def extract_code_blocks(self, old_code: str, new_code: str, changed_line_number: int) -> Tuple[str, str]:
        """Extract the relevant code blocks from old and new code based on a single changed line."""
        # Find if the changed line is within a function
        old_boundaries = self.find_function_boundaries(old_code, changed_line_number)
        
        if old_boundaries:
            # Change is inside a function
            start_line, end_line = old_boundaries
            old_lines = old_code.split('\n')
            new_lines = new_code.split('\n')
            
            vulnerable_block = '\n'.join(old_lines[start_line-1:end_line])
            
            # Try to find the corresponding function in the new code
            # For regex-based parsing, use the same boundaries as a simple heuristic
            patched_block = '\n'.join(new_lines[start_line-1:end_line])
            
            return vulnerable_block, patched_block
        else:
            # Change is outside any function
            old_lines = old_code.split('\n')
            new_lines = new_code.split('\n')
            
            vulnerable_block = old_lines[changed_line_number - 1]
            patched_block = new_lines[changed_line_number - 1]
            
            return vulnerable_block, patched_block

    def is_single_line_change(self, old_code: str, new_code: str) -> Optional[int]:
        """Determine if there is exactly one line changed between old and new code."""
        old_lines = old_code.split('\n')
        new_lines = new_code.split('\n')
        
        if len(old_lines) != len(new_lines):
            return None
            
        diff_count = 0
        changed_line = None
        
        for i, (old_line, new_line) in enumerate(zip(old_lines, new_lines)):
            if old_line != new_line:
                diff_count += 1
                changed_line = i + 1
                if diff_count > 1:
                    return None
                    
        return changed_line if diff_count == 1 else None 