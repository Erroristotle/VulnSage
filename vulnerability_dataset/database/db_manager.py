import sqlite3
import pandas as pd
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import logging
from ..config import settings
from .db_utils import get_db_connection

logger = logging.getLogger(__name__)

class DatabaseManager:
    def __init__(self, db_path: str = None):
        self.db_path = db_path or settings.DB_PATH

    def create_database(self, raw_data_path: str = None) -> Dict[str, int]:
        """Create and initialize the vulnerability database."""
        raw_data_path = raw_data_path or settings.RAW_DATASET_PATH
        logger.info(f"Creating database from {raw_data_path}")

        # Read and process raw data
        raw_data = pd.read_csv(raw_data_path)
        project_data = {
            project: raw_data[raw_data['R_ID'] == project_id]
            for project, project_id in settings.PROJECT_IDS.items()
        }

        # Remove existing database if it exists
        if Path(self.db_path).exists():
            Path(self.db_path).unlink()

        with get_db_connection(self.db_path) as (conn, cursor):
            self._create_table(cursor)
            stats = self._insert_initial_data(cursor, project_data)
            conn.commit()
            return stats

    def _create_table(self, cursor: sqlite3.Cursor) -> None:
        """Create the vulnerabilities table."""
        fields = [
            "COMMIT_HASH", "VULNERABILITY_CVE", "VULNERABILITY_YEAR",
            "VULNERABILITY_CWE", "VULNERABILITY_CATEGORY",
            "DESCRIPTION_IN_PATCH", "VULNERABLE_CODE_BLOCK",
            "PATCHED_CODE_BLOCK", "NUM_FILES_CHANGED",
            "NUM_FUNCTIONS_CHANGED", "NUM_LINES_ADDED",
            "NUM_LINES_DELETED", "NUM_LINES_IN_VULNERABLE_CODE_BLOCK",
            "NUM_LINES_IN_PATCHED_CODE_BLOCK"
        ]
        
        cursor.execute(f'''
        CREATE TABLE IF NOT EXISTS vulnerabilities (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            {', '.join([f"{field} TEXT" for field in fields])},
            PROJECT TEXT
        )
        ''')

    def _insert_initial_data(self, cursor: sqlite3.Cursor, 
                           project_data: Dict[str, pd.DataFrame]) -> Dict[str, int]:
        """Insert initial data into database."""
        existing_fields = [
            "COMMIT_HASH", "VULNERABILITY_CVE", "VULNERABILITY_YEAR",
            "VULNERABILITY_CWE", "VULNERABILITY_CATEGORY"
        ]
        
        stats = {}
        for project, df in project_data.items():
            df_filtered = df[existing_fields]
            
            for _, row in df_filtered.iterrows():
                cursor.execute('''
                INSERT INTO vulnerabilities 
                (COMMIT_HASH, VULNERABILITY_CVE, VULNERABILITY_YEAR, 
                 VULNERABILITY_CWE, VULNERABILITY_CATEGORY, PROJECT)
                VALUES (?, ?, ?, ?, ?, ?)
                ''', (*row, project))
                
            stats[project] = len(df)
            
        return stats

    def update_code_blocks(self, commit_hash: str, project: str,
                         vulnerable_code: str, patched_code: str,
                         metadata: Dict) -> None:
        """Update code blocks and metadata for a specific vulnerability."""
        with get_db_connection(self.db_path) as (conn, cursor):
            cursor.execute('''
            UPDATE vulnerabilities
            SET VULNERABLE_CODE_BLOCK = ?,
                PATCHED_CODE_BLOCK = ?,
                NUM_FILES_CHANGED = ?,
                NUM_FUNCTIONS_CHANGED = ?,
                NUM_LINES_ADDED = ?,
                NUM_LINES_DELETED = ?,
                DESCRIPTION_IN_PATCH = ?
            WHERE COMMIT_HASH = ? AND PROJECT = ?
            ''', (
                vulnerable_code,
                patched_code,
                metadata.get('num_files_changed'),
                metadata.get('num_functions_changed'),
                metadata.get('num_lines_added'),
                metadata.get('num_lines_deleted'),
                metadata.get('description'),
                commit_hash,
                project
            ))
            conn.commit()

    def get_statistics(self) -> Dict[str, Dict]:
        """Get database statistics."""
        with get_db_connection(self.db_path) as (conn, cursor):
            # Get overall statistics
            cursor.execute("""
                SELECT 
                    PROJECT,
                    COUNT(*) as count,
                    COUNT(DISTINCT VULNERABILITY_CWE) as unique_cwes,
                    AVG(NUM_LINES_IN_VULNERABLE_CODE_BLOCK) as avg_vuln_lines,
                    AVG(NUM_LINES_IN_PATCHED_CODE_BLOCK) as avg_patch_lines
                FROM vulnerabilities
                GROUP BY PROJECT
            """)
            
            stats = {}
            for row in cursor.fetchall():
                project, count, unique_cwes, avg_vuln, avg_patch = row
                stats[project] = {
                    'count': count,
                    'unique_cwes': unique_cwes,
                    'avg_vulnerable_lines': avg_vuln,
                    'avg_patched_lines': avg_patch
                }
            
            return stats