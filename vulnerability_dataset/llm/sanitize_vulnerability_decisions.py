import sqlite3
import logging
import re
from typing import Optional

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilityDetectionSanitizer:
    def __init__(self, db_path: str = "vulnerability_dataset/database/database.sqlite"):
        self.db_path = db_path

    def extract_decision_from_reasoning(self, reasoning: str) -> Optional[int]:
        """Extract vulnerability decision from reasoning text."""
        if not reasoning:
            return None
            
        reasoning_lower = reasoning.lower()
        
        # Clear vulnerability indicators - use raw strings for regex patterns
        vulnerable_indicators = [
            r"is vulnerable",
            r"contains vulnerability",
            r"has vulnerability",
            r"vulnerable to",
            r"security vulnerability",
            r"security issue",
            r"can be exploited",
            r"unsafe",
            r"security risk",
            r"verified cwe-",
            r"identified a verified",
            r"\*\*potential cwe\*\*",  # Escaped asterisks
            r"the verified instance",
            r"is present in this code",
            r"vulnerability exists",
            r"found in the code",
            r"cwe-\d{1,3}\s+is\s+present",
            r"CWE-\d{1,3}\s+is\s+present\s+in\s+this\s+codebase",
            r"Presence of CWE-\d{1,3}: Yes",
            
        ]
        
        # Clear non-vulnerability indicators
        safe_indicators = [
            r"not vulnerable",
            r"no vulnerability",
            r"has been fixed",
            r"is secure",
            r"is safe",
            r"properly handled",
            r"correctly validates",
            r"properly validates",
            r"has been patched",
            r"is not directly present",
            r"does not appear",
            r"there isn't explicit evidence of",
            r"is not present in this code",
            r"the code seems secure",
            r"there is no evidence of",
            r"no instances of cwe",
            r"not present in this specific code",
            r"does not contain",
            r"no conclusive presence",
            r"cannot identify",
            r"were not found",
            r"presence of cwe-[0-9]+:\s*no",  # Fixed regex pattern
            r"no\s+vulnerability\s+found",     # Fixed regex pattern
            r"CWE-\d{1,3}\s+is\s+not\s+present",
            r"no\s+direct\s+information\s+of\s+CWE-\d{1,3}",
            r"no\s+conclusive\s+evidence\s+that\s+CWE-\d{1,3}\s+is\s+present",
            r"Presence of CWE-\d{1,3}: No",
        ]
        
        # Ambiguity indicators
        ambiguous_indicators = [
            r"need more information",
            r"ambiguous",
            r"without a comprehensive review",
            r"difficult to give a definitive",
            r"cannot determine",
            r"cannot be determined",
            r"insufficient information",
            r"more context needed",
            r"requires further analysis",
            r"not enough context"
        ]
        
        # Check for explicit vulnerability statements
        for indicator in vulnerable_indicators:
            if re.search(indicator, reasoning_lower) and not any(re.search(safe, reasoning_lower) for safe in safe_indicators):
                return 1
                
        # Check for explicit safety statements
        for indicator in safe_indicators:
            if re.search(indicator, reasoning_lower):
                return 0
                
        # Check for ambiguity
        for indicator in ambiguous_indicators:
            if re.search(indicator, reasoning_lower):
                return 2
                
        # Default to ambiguous if no clear indicators are found
        return 2

    def validate_decision(self, decision: Optional[int], reasoning: str) -> bool:
        """Validate if the vulnerability decision seems reasonable based on reasoning."""
        if decision is None or not reasoning:
            return False
            
        if decision not in [0, 1, 2]:
            return False
            
        # Additional validation logic could be added here
        return True

    def update_table_decisions(self, table_name: str):
        """Update vulnerability decisions for a specific table based on reasoning."""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # First get column names from the table
            cursor.execute(f"PRAGMA table_info({table_name})")
            columns = [col[1] for col in cursor.fetchall()]
            
            # Check if we have a primary key column
            id_column = 'rowid'  # SQLite default
            if 'ID' in columns:
                id_column = 'ID'
            elif 'id' in columns:
                id_column = 'id'
            
            # First, reset all decision columns to NULL
            logger.info("Resetting existing decisions...")
            cursor.execute(f"""
                UPDATE {table_name}
                SET COT_VULN = NULL,
                    COT_PATCH = NULL,
                    THINK_VULN = NULL,
                    THINK_PATCH = NULL,
                    THINK_VERIFY_VULN = NULL,
                    THINK_VERIFY_PATCH = NULL
            """)
            conn.commit()
            logger.info("Reset complete. Starting analysis...")
            
            # Get all rows with reasoning
            cursor.execute(f"""
                SELECT {id_column}, 
                       COT_REASONING_VULN, COT_REASONING_PATCH,
                       THINK_REASONING_VULN, THINK_REASONING_PATCH,
                       THINK_VERIFY_REASONING_VULN, THINK_VERIFY_REASONING_PATCH
                FROM {table_name}
            """)
            
            rows = cursor.fetchall()
            logger.info(f"Processing {len(rows)} rows in {table_name}")
            
            updates = 0
            for row in rows:
                (row_id, cot_reas_vuln, cot_reas_patch, 
                 think_reas_vuln, think_reas_patch,
                 verify_reas_vuln, verify_reas_patch) = row
                
                # Process each pair of reasoning and decision
                pairs = [
                    ('COT_VULN', cot_reas_vuln),
                    ('COT_PATCH', cot_reas_patch),
                    ('THINK_VULN', think_reas_vuln),
                    ('THINK_PATCH', think_reas_patch),
                    ('THINK_VERIFY_VULN', verify_reas_vuln),
                    ('THINK_VERIFY_PATCH', verify_reas_patch)
                ]
                
                for column, reasoning in pairs:
                    if reasoning:
                        extracted_decision = self.extract_decision_from_reasoning(reasoning)
                        if extracted_decision is not None and self.validate_decision(extracted_decision, reasoning):
                            cursor.execute(f"""
                                UPDATE {table_name}
                                SET {column} = ?
                                WHERE {id_column} = ?
                            """, (extracted_decision, row_id))
                            
                            updates += 1
                            logger.info(f"Updated row {row_id} {column} -> {extracted_decision}")
            
            conn.commit()
            logger.info(f"Completed {updates} updates in {table_name}")
            
        except Exception as e:
            logger.error(f"Error updating {table_name}: {e}")
            if 'conn' in locals():
                conn.rollback()
        finally:
            if 'conn' in locals():
                conn.close()

def main():
    sanitizer = VulnerabilityDetectionSanitizer()
    
    # Start with llama3 table
    logger.info("Processing vulnerabilities_llama3_1_8b table...")
    sanitizer.update_table_decisions("vulnerabilities_llama3_1_8b")

if __name__ == "__main__":
    main() 