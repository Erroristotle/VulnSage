import sqlite3
import logging
from pathlib import Path
import os
from .function_counter import LLMFunctionCounter

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def update_function_counts(db_path: str = None):
    """Update function counts using LLM for all entries in database."""
    
    # Get the correct database path
    if db_path is None:
        db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'database.sqlite')
    
    if not os.path.exists(db_path):
        raise FileNotFoundError(f"Database file not found at: {db_path}")
        
    logger.info(f"Using database at: {db_path}")
    
    # Initialize function counter with codellama model
    function_counter = LLMFunctionCounter(model_name="codellama")
    
    try:
        # Connect to database
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Verify table exists
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='vulnerabilities'
        """)
        
        if not cursor.fetchone():
            raise Exception("vulnerabilities table not found in database")
        
        # Get all code blocks
        cursor.execute("""
            SELECT COMMIT_HASH, VULNERABLE_CODE_BLOCK, PATCHED_CODE_BLOCK, PROJECT 
            FROM vulnerabilities
            WHERE VULNERABLE_CODE_BLOCK IS NOT NULL 
               OR PATCHED_CODE_BLOCK IS NOT NULL
        """)
        
        rows = cursor.fetchall()
        total = len(rows)
        logger.info(f"Found {total} entries to process")
        
        # Process each entry
        for i, (commit_hash, vuln_code, patched_code, project) in enumerate(rows, 1):
            try:
                # Count functions in both versions
                vuln_functions = function_counter.count_functions(vuln_code) if vuln_code else 0
                patched_functions = function_counter.count_functions(patched_code) if patched_code else 0
                
                # Use the maximum as the number of functions changed
                functions_changed = max(vuln_functions, patched_functions)
                
                # Update database
                cursor.execute("""
                    UPDATE vulnerabilities
                    SET NUM_FUNCTIONS_CHANGED = ?
                    WHERE COMMIT_HASH = ? AND PROJECT = ?
                """, (functions_changed, commit_hash, project))
                
                if i % 10 == 0:  # Commit every 10 entries
                    conn.commit()
                    logger.info(f"Processed {i}/{total} entries")
                    logger.info(f"Last entry: {commit_hash} - Functions changed: {functions_changed}")
                
            except Exception as e:
                logger.error(f"Error processing {commit_hash}: {e}")
                continue
        
        # Final commit
        conn.commit()
        
        # Print summary
        cursor.execute("""
            SELECT PROJECT, 
                   COUNT(*) as count,
                   AVG(NUM_FUNCTIONS_CHANGED) as avg_functions
            FROM vulnerabilities
            GROUP BY PROJECT
        """)
        
        print("\nSummary of function counts by project:")
        for project, count, avg_functions in cursor.fetchall():
            print(f"{project}:")
            print(f"  Count: {count}")
            print(f"  Average functions changed: {avg_functions:.2f}")
        
    except Exception as e:
        logger.error(f"Database error: {e}")
        raise
    finally:
        if 'conn' in locals():
            conn.close()

if __name__ == "__main__":
    update_function_counts()