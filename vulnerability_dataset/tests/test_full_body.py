#!/usr/bin/env python3
import os
import sys
import clang.cindex
import platform

# Configure libclang path based on OS
if platform.system() == "Darwin":
    clang.cindex.Config.set_library_file("/Applications/Xcode.app/Contents/Frameworks/libclang.dylib")
elif platform.system() == "Linux":
    possible_paths = [
        "/usr/lib/llvm-11/lib/libclang.so",
        "/usr/lib/libclang.so",
        "/usr/lib/llvm/lib/libclang.so"
    ]
    for path in possible_paths:
        if os.path.exists(path):
            clang.cindex.Config.set_library_file(path)
            break

def find_function_by_text(source_code, function_name):
    """
    Find a function using text parsing, more suitable for C files.
    """
    lines = source_code.split('\n')
    for i, line in enumerate(lines):
        # Look for the function definition
        if function_name in line and '(' in line and not line.strip().startswith('//'):
            # Verify it's a function definition
            words = line.strip().split()
            if function_name in words or f"{function_name}(" in line:
                print(f"Found potential function definition (text): {line.strip()}")
                
                # Find the opening brace
                brace_count = 0
                start_line = i
                found_opening = False
                
                # Look backwards for any function header lines
                while start_line > 0 and not lines[start_line-1].strip().endswith(';'):
                    start_line -= 1
                    if lines[start_line].strip().startswith('/*') or lines[start_line].strip().startswith('*'):
                        continue
                    if lines[start_line].strip():
                        break
                
                # Collect the function
                function_lines = []
                for j in range(start_line, len(lines)):
                    current_line = lines[j]
                    function_lines.append(current_line)
                    
                    # Count braces
                    for char in current_line:
                        if char == '{':
                            found_opening = True
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                    
                    # Check if we've found the end of the function
                    if found_opening and brace_count == 0:
                        return '\n'.join(function_lines)
    
    return None

def find_function_by_clang(source_code, function_name, class_name=None, filename=None):
    """
    Find a function using Clang parsing, better for C++ files.
    """
    index = clang.cindex.Index.create()
    
    # Base compilation arguments
    args = [
        "-x", "c++",
        "--std=c++11",
        "-fparse-all-comments",
        "-I/usr/include",
        "-I/usr/local/include",
        "-I.",
        "-DMOZILLA_INTERNAL_API",
        "-DNDEBUG",
        "-DTRIMMED"
    ]

    try:
        tu = index.parse(
            filename or "temp.cpp",
            args=args,
            unsaved_files=[(filename or "temp.cpp", source_code)],
            options=clang.cindex.TranslationUnit.PARSE_SKIP_FUNCTION_BODIES
        )
    except Exception as e:
        print(f"[ERROR] Clang failed to parse {filename}: {e}")
        return None

    if not tu:
        print("[ERROR] Failed to create translation unit")
        return None

    # Print diagnostics at severity level Warning and above
    for diag in tu.diagnostics:
        if diag.severity >= clang.cindex.Diagnostic.Warning:
            severity = {
                2: "Warning",
                3: "Error",
                4: "Fatal"
            }.get(diag.severity, "Unknown")
            print(f"[{severity}] {diag.spelling}")

    # First try to find the function with string matching
    for line in source_code.split('\n'):
        # Handle class member function
        if class_name:
            search_pattern = f"{class_name}::{function_name}"
        else:
            # For standalone functions, look for the function name at a word boundary
            words = line.split()
            if function_name in words and '(' in line:
                search_pattern = function_name
            else:
                continue
        
        if search_pattern in line:
            print(f"Found potential function definition (clang): {line.strip()}")
            start_idx = source_code.find(line)
            if start_idx != -1:
                # Try to capture the entire function
                brace_count = 0
                end_idx = start_idx
                found_opening = False
                
                for i in range(start_idx, len(source_code)):
                    if source_code[i] == '{':
                        found_opening = True
                        brace_count += 1
                    elif source_code[i] == '}':
                        brace_count -= 1
                        if found_opening and brace_count == 0:
                            end_idx = i + 1
                            break
                
                if end_idx > start_idx:
                    return source_code[start_idx:end_idx]
    
    return None

def find_function(source_code, function_name, class_name=None, filename=None):
    """
    Try both Clang and text-based parsing to find the function.
    """
    # Try text-based parsing first
    func_def = find_function_by_text(source_code, function_name)
    if func_def:
        print("Found function using text-based parsing")
        return func_def

    # If text-based parsing fails, try Clang
    func_def = find_function_by_clang(source_code, function_name, class_name, filename)
    if func_def:
        print("Found function using Clang parsing")
        return func_def

    return None

def main():
    test_cases = [

        {
            "filename": "b59073dc8fae65cd9dc81c0137b0f7a9911873e2_curr_nsJSEnvironment.cpp",
            "function_name": "ScriptErrorEvent",
            "class_name": "",
        }

    ]
    
    test_case = test_cases[0]
    
    try:
        with open(test_case["filename"], "r", encoding="utf-8") as f:
            source_code = f.read()
    except Exception as e:
        print(f"[ERROR] Could not read file {test_case['filename']}: {e}")
        sys.exit(1)

    func_def = find_function(
        source_code,
        test_case["function_name"],
        test_case.get("class_name"),
        test_case["filename"]
    )
    
    if func_def:
        print("\n========== Found Function ==========\n")
        print(func_def)
        print("\n==================================\n")
    else:
        function_desc = (f"{test_case.get('class_name')}::{test_case['function_name']}" 
                        if test_case.get('class_name') 
                        else test_case['function_name'])
        print(f"[INFO] Could not find function {function_desc} in {test_case['filename']}")
        print("\nFirst few lines of the file:")
        print("\n".join(source_code.split("\n")[:10]))

if __name__ == "__main__":
    main()