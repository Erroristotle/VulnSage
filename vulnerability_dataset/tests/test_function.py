def extract_functions_from_patch(patch_content):
    """
    Extract all function names from a patch/diff file where changes (+ or -) occurred.
    Returns a list of tuples (function_name, class_name).
    """
    lines = patch_content.split('\n')
    current_function = None
    current_class = None
    in_function = False
    functions = []
    
    for i, line in enumerate(lines):
        stripped_line = line.strip()
        
        # Handle @@ context lines
        if line.startswith('@@'):
            # Reset function context at new diff chunk
            in_function = False
            current_function = None
            current_class = None

            if '@@ ' in line:
                context_part = line.split('@@ ')[-1].strip()
                # New: if context starts with "class ", extract the class declaration
                if context_part.startswith("class "):
                    parts = context_part.split()
                    if len(parts) >= 2:
                        current_function = parts[1].strip()  # Extract the class name as function name
                        current_class = None
                        in_function = True
                elif '::' in context_part:
                    parts = context_part.split('::')
                    current_class = parts[0].strip().replace('@', '').strip()
                    current_function = parts[1].split('(')[0].strip()
                    in_function = True
                else:
                    parts = context_part.split('(')
                    if len(parts) > 1:
                        func_parts = parts[0].split()
                        if func_parts:
                            current_function = func_parts[-1].strip()
                            current_class = None
                            in_function = True

        # Look for function declaration in code
        if not in_function:
            if '::' in stripped_line and '(' in stripped_line and not stripped_line.startswith(('+', '-', '//', '@')):
                # C++ member function
                parts = stripped_line.split('::')
                if len(parts) == 2:
                    current_class = parts[0].strip()
                    current_function = parts[1].split('(')[0].strip()
                    in_function = True
            elif '(' in stripped_line and not stripped_line.startswith(('+', '-', '//', '@', '}')):
                # C-style function
                parts = stripped_line.split('(')[0].strip().split()
                if parts and not parts[0] in ['if', 'while', 'for', 'switch', 'return']:
                    current_function = parts[-1]
                    current_class = None
                    in_function = True
        
        # If we're in a function and find a change line, add to our list if not already present
        if in_function and line.startswith(('+', '-')) and not line.startswith(('+++ ', '--- ')):
            # Clean up class name if it still contains @@ markers
            if current_class and '@' in current_class:
                current_class = current_class.split('@')[-1].strip()
            
            # Create tuple of current function context
            current = (current_function, current_class)
            
            # Only add if not already in our list
            if current not in functions:
                functions.append(current)
                
    return functions

# Test cases
test_patches = [
    """"""
]

# Test both cases
for i, patch in enumerate(test_patches, 1):
    functions = extract_functions_from_patch(patch)
    print(f"\nTest case {i}:")
    if functions:
        for func_name, class_name in functions:
            if class_name:
                print(f"Function name: {func_name}, Class name: {class_name}")
            else:
                print(f"Function name: {func_name}")
    else:
        print("No functions found with changes")

# Test cases
test_patches = [
    # Test case 1: Function with direct declaration
    """diff --git a/netwerk/base/src/nsBaseChannel.cpp b/netwerk/base/src/nsBaseChannel.cpp
@@ -253,16 +253,19 @@ void
nsBaseChannel::HandleAsyncRedirect(nsIChannel* newChannel)
{
  NS_ASSERTION(!mPump, "Shouldn't have gotten here");
+  PRBool doNotify = PR_TRUE;""",

    # Test case 2: Function in @@ context line
    """diff --git a/editor/libeditor/base/nsEditor.cpp b/editor/libeditor/base/nsEditor.cpp
@@ -3397,7 +3397,7 @@ nsEditor::FindNode(nsINode *aCurrentNode,
    return nullptr;
  }

-  nsIContent* candidate =
+  nsCOMPtr<nsIContent> candidate =""",

    # Test case 3: Function with multiple changes

"""From 7b1c513be6bdbc0552bea0c1d312507337f4e5cd Mon Sep 17 00:00:00 2001
From: Ehsan Akhgari <ehsan@mozilla.com>
Date: Tue, 20 Jul 2010 09:04:14 -0400
Subject: [PATCH] Bug 580151 - Part 1: Move the increment up in case the call
 to nsIEditor::GetSelection fails and we bail out early; r=roc

--HG--
extra : rebase_source : 249cf74c6a1700b230d946793819ff6611ebbb99
---
 editor/libeditor/text/nsTextEditRules.cpp | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/editor/libeditor/text/nsTextEditRules.cpp b/editor/libeditor/text/nsTextEditRules.cpp
index ee8e77d9717bb..56e2b655bc6db 100644
--- a/editor/libeditor/text/nsTextEditRules.cpp
+++ b/editor/libeditor/text/nsTextEditRules.cpp
@@ -221,6 +221,12 @@ nsTextEditRules::BeforeEdit(PRInt32 action, nsIEditor::EDirection aDirection)
   
   nsAutoLockRulesSniffing lockIt(this);
   mDidExplicitlySetInterline = PR_FALSE;
+  if (!mActionNesting)
+  {
+    // let rules remember the top level action
+    mTheAction = action;
+  }
+  mActionNesting++;
   
   // get the selection and cache the position before editing
   nsCOMPtr<nsISelection> selection;
@@ -230,12 +236,6 @@ nsTextEditRules::BeforeEdit(PRInt32 action, nsIEditor::EDirection aDirection)
   selection->GetAnchorNode(getter_AddRefs(mCachedSelectionNode));
   selection->GetAnchorOffset(&mCachedSelectionOffset);
 
-  if (!mActionNesting)
-  {
-    // let rules remember the top level action
-    mTheAction = action;
-  }
-  mActionNesting++;
   return NS_OK;
 }
 """,
 
 #  Test case 4: linux
 """From 8c34e2d63231d4bf4852bac8521883944d770fe3 Mon Sep 17 00:00:00 2001
From: Jens Axboe <jens.axboe@oracle.com>
Date: Tue, 17 Oct 2006 19:43:22 +0200
Subject: [PATCH] [PATCH] Remove SUID when splicing into an inode

Originally from Mark Fasheh <mark.fasheh@oracle.com>

generic_file_splice_write() does not remove S_ISUID or S_ISGID. This is
inconsistent with the way we generally write to files.

Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
Signed-off-by: Jens Axboe <jens.axboe@oracle.com>
---
 fs/splice.c | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/fs/splice.c b/fs/splice.c
index 68e20e65c6e114..49fb9f12993884 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -845,6 +845,10 @@ generic_file_splice_write_nolock(struct pipe_inode_info *pipe, struct file *out,
 	ssize_t ret;
 	int err;
 
+	err = remove_suid(out->f_dentry);
+	if (unlikely(err))
+		return err;
+
 	ret = __splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_file);
 	if (ret > 0) {
 		*ppos += ret;
@@ -883,12 +887,21 @@ generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,
 			  loff_t *ppos, size_t len, unsigned int flags)
 {
 	struct address_space *mapping = out->f_mapping;
+	struct inode *inode = mapping->host;
 	ssize_t ret;
+	int err;
+
+	err = should_remove_suid(out->f_dentry);
+	if (unlikely(err)) {
+		mutex_lock(&inode->i_mutex);
+		err = __remove_suid(out->f_dentry, err);
+		mutex_unlock(&inode->i_mutex);
+		if (err)
+			return err;
+	}
 
 	ret = splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_file);
 	if (ret > 0) {
-		struct inode *inode = mapping->host;
-
 		*ppos += ret;
 
 		/*
@@ -896,8 +909,6 @@ generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,
 		 * sync it.
 		 */
 		if (unlikely((out->f_flags & O_SYNC) || IS_SYNC(inode))) {
-			int err;
-
 			mutex_lock(&inode->i_mutex);
 			err = generic_osync_inode(inode, mapping,
 						  OSYNC_METADATA|OSYNC_DATA);

""",
# test case 5: linux
"""From 47d439e9fb8a81a90022cfa785bf1c36c4e2aff6 Mon Sep 17 00:00:00 2001
From: Eric Paris <eparis@redhat.com>
Date: Fri, 7 Aug 2009 14:53:57 -0400
Subject: [PATCH] security: define round_hint_to_min in !CONFIG_SECURITY

Fix the header files to define round_hint_to_min() and to define
mmap_min_addr_handler() in the !CONFIG_SECURITY case.

Built and tested with !CONFIG_SECURITY

Signed-off-by: Eric Paris <eparis@redhat.com>
Signed-off-by: James Morris <jmorris@namei.org>
---
 include/linux/security.h | 30 +++++++++++++++---------------
 1 file changed, 15 insertions(+), 15 deletions(-)

diff --git a/include/linux/security.h b/include/linux/security.h
index 7b431155e392ee..57ead99d259361 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -121,6 +121,21 @@ struct request_sock;
 #define LSM_UNSAFE_PTRACE	2
 #define LSM_UNSAFE_PTRACE_CAP	4
 
+/*
+ * If a hint addr is less than mmap_min_addr change hint to be as
+ * low as possible but still greater than mmap_min_addr
+ */
+static inline unsigned long round_hint_to_min(unsigned long hint)
+{
+	hint &= PAGE_MASK;
+	if (((void *)hint != NULL) &&
+	    (hint < mmap_min_addr))
+		return PAGE_ALIGN(mmap_min_addr);
+	return hint;
+}
+extern int mmap_min_addr_handler(struct ctl_table *table, int write, struct file *filp,
+				 void __user *buffer, size_t *lenp, loff_t *ppos);
+
 #ifdef CONFIG_SECURITY
 
 struct security_mnt_opts {
@@ -149,21 +164,6 @@ static inline void security_free_mnt_opts(struct security_mnt_opts *opts)
 	opts->num_mnt_opts = 0;
 }
 
-/*
- * If a hint addr is less than mmap_min_addr change hint to be as
- * low as possible but still greater than mmap_min_addr
- */
-static inline unsigned long round_hint_to_min(unsigned long hint)
-{
-	hint &= PAGE_MASK;
-	if (((void *)hint != NULL) &&
-	    (hint < mmap_min_addr))
-		return PAGE_ALIGN(mmap_min_addr);
-	return hint;
-}
-
-extern int mmap_min_addr_handler(struct ctl_table *table, int write, struct file *filp,
-				 void __user *buffer, size_t *lenp, loff_t *ppos);
 /**
  * struct security_operations - main security structure
  *
""",
"""From b59073dc8fae65cd9dc81c0137b0f7a9911873e2 Mon Sep 17 00:00:00 2001
From: Boris Zbarsky <bzbarsky@mit.edu>
Date: Tue, 8 Jun 2010 15:58:26 -0400
Subject: [PATCH] Bug 568564.  Suppress the script filename for cross-origin
 onerror events.  r=jst

---
 content/base/test/test_bug461735.html | 2 +-
 dom/base/nsJSEnvironment.cpp          | 4 ++++
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/content/base/test/test_bug461735.html b/content/base/test/test_bug461735.html
index 61cb4cd647663..f1956998f9120 100644
--- a/content/base/test/test_bug461735.html
+++ b/content/base/test/test_bug461735.html
@@ -19,7 +19,7 @@
 <script type="application/javascript">
 window.onerror = function(message, uri, line) {
   is(message, "Script error.", "Should have empty error message");
-  is(uri, "http://example.com/tests/content/base/test/bug461735-post-redirect.js", "Unexpected error location URI");
+  is(uri, "", "Should have empty error location URI");
   is(line, 0, "Shouldn't have a line here");
 }
 </script>
diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
index 42537280dee3e..54180a3f076d5 100644
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -475,6 +475,10 @@ class ScriptErrorEvent : public nsRunnable
             NS_WARNING("Not same origin error!");
             errorevent.errorMsg = xoriginMsg.get();
             errorevent.lineNr = 0;
+            // FIXME: once the principal of the script is not tied to
+            // the filename, we can stop using the post-redirect
+            // filename if we want and remove this line.
+            errorevent.fileName = nsnull;
           }
 
           nsEventDispatcher::Dispatch(win, presContext, &errorevent, nsnull,"""
 
]

# Test both cases
for i, patch in enumerate(test_patches, 1):
    functions = extract_functions_from_patch(patch)
    print(f"\nTest case {i}:")
    if functions:
        for func_name, class_name in functions:
            if class_name:
                print(f"Function name: {func_name}, Class name: {class_name}")
            else:
                print(f"Function name: {func_name}")
    else:
        print("No functions found with changes")