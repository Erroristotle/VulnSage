#!/usr/bin/env python3
import os
import sys
import subprocess
import re
import sqlite3
import platform
import clang.cindex

# -------------------------------------------------------------------
# Configure libclang path based on OS
if platform.system() == "Darwin":
    clang.cindex.Config.set_library_file("/Applications/Xcode.app/Contents/Frameworks/libclang.dylib")
elif platform.system() == "Linux":
    possible_paths = [
        "/usr/lib/llvm-11/lib/libclang.so",
        "/usr/lib/libclang.so",
        "/usr/lib/llvm/lib/libclang.so"
    ]
    for path in possible_paths:
        if os.path.exists(path):
            clang.cindex.Config.set_library_file(path)
            break
# -------------------------------------------------------------------
# Function extraction routines using text-based and Clang-based methods

def find_function(source_code, function_name, class_name=None, filename=None):
    """
    Find a function definition in the given source code using text- and Clang-based parsing.
    Returns the complete function definition if found; otherwise, None.
    """
    lines = source_code.split('\n')
    for i, line in enumerate(lines):
        if function_name in line and '(' in line and not line.strip().startswith('//'):
            words = line.strip().split()
            if function_name in words or f"{function_name}(" in line:
                brace_count = 0
                start_line = i
                found_opening = False
                while start_line > 0 and not lines[start_line - 1].strip().endswith(';'):
                    start_line -= 1
                    if lines[start_line].strip().startswith('/*') or lines[start_line].strip().startswith('*'):
                        continue
                    if lines[start_line].strip():
                        break
                function_lines = []
                for j in range(start_line, len(lines)):
                    current_line = lines[j]
                    function_lines.append(current_line)
                    for char in current_line:
                        if char == '{':
                            found_opening = True
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                    if found_opening and brace_count == 0:
                        return '\n'.join(function_lines)
    # Fallback: Clang-based parsing
    import clang.cindex
    index = clang.cindex.Index.create()
    args = [
        "-x", "c++",
        "--std=c++11",
        "-fparse-all-comments",
        "-I/usr/include",
        "-I/usr/local/include",
        "-I.",
        "-DMOZILLA_INTERNAL_API",
        "-DNDEBUG",
        "-DTRIMMED"
    ]
    try:
        tu = index.parse(filename or "temp.cpp",
                         args=args,
                         unsaved_files=[(filename or "temp.cpp", source_code)],
                         options=clang.cindex.TranslationUnit.PARSE_SKIP_FUNCTION_BODIES)
    except Exception as e:
        print(f"[ERROR] Clang failed to parse {filename}: {e}")
        return None
    if not tu:
        print("[ERROR] Failed to create translation unit")
        return None
    for diag in tu.diagnostics:
        if diag.severity >= clang.cindex.Diagnostic.Warning:
            severity = {2: "Warning", 3: "Error", 4: "Fatal"}.get(diag.severity, "Unknown")
            print(f"[{severity}] {diag.spelling}")
    for line in source_code.split('\n'):
        if class_name:
            search_pattern = f"{class_name}::{function_name}"
        else:
            words = line.split()
            if function_name in words and '(' in line:
                search_pattern = function_name
            else:
                continue
        if search_pattern in line:
            start_idx = source_code.find(line)
            if start_idx != -1:
                brace_count = 0
                end_idx = start_idx
                found_opening = False
                for i in range(start_idx, len(source_code)):
                    if source_code[i] == '{':
                        found_opening = True
                        brace_count += 1
                    elif source_code[i] == '}':
                        brace_count -= 1
                        if found_opening and brace_count == 0:
                            end_idx = i + 1
                            break
                if end_idx > start_idx:
                    return source_code[start_idx:end_idx]
    return None

def extract_functions_from_patch(patch_content):
    """
    Extract all function names from a patch/diff file where changes occurred.
    Returns a list of tuples (function_name, class_name).
    """
    lines = patch_content.split('\n')
    current_function = None
    current_class = None
    in_function = False
    functions = []
    
    for i, line in enumerate(lines):
        stripped_line = line.strip()
        if line.startswith('@@'):
            in_function = False
            current_function = None
            current_class = None
            if '@@ ' in line:
                context_part = line.split('@@ ')[-1].strip()
                if '::' in context_part:
                    parts = context_part.split('::')
                    current_class = parts[0].strip().replace('@', '').strip()
                    current_function = parts[1].split('(')[0].strip()
                    in_function = True
                else:
                    parts = context_part.split('(')
                    if len(parts) > 1:
                        func_parts = parts[0].split()
                        if func_parts:
                            current_function = func_parts[-1].strip()
                            current_class = None
                            in_function = True
        if not in_function:
            if '::' in stripped_line and '(' in stripped_line and not stripped_line.startswith(('+', '-', '//', '@')):
                parts = stripped_line.split('::')
                if len(parts) == 2:
                    current_class = parts[0].strip()
                    current_function = parts[1].split('(')[0].strip()
                    in_function = True
            elif '(' in stripped_line and not stripped_line.startswith(('+', '-', '//', '@', '}')):
                parts = stripped_line.split('(')[0].strip().split()
                if parts and not parts[0] in ['if', 'while', 'for', 'switch', 'return']:
                    current_function = parts[-1]
                    current_class = None
                    in_function = True
        if in_function and line.startswith(('+', '-')) and not line.startswith(('+++ ', '--- ')):
            if current_class and '@' in current_class:
                current_class = current_class.split('@')[-1].strip()
            current = (current_function, current_class)
            if current not in functions:
                functions.append(current)
    return functions

def get_patch(repo_path, commit_hash):
    """
    Retrieve the full patch (diff) for the given commit.
    """
    cmd = ["git", "show", commit_hash]
    try:
        result = subprocess.run(cmd, cwd=repo_path, text=True, capture_output=True, check=True, errors='replace')
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Failed to get patch for commit {commit_hash}: {e}")
        return None

def get_changed_files(repo_path, commit_hash):
    """
    Use git diff-tree to list all files changed in the given commit.
    """
    cmd = ["git", "diff-tree", "--no-commit-id", "--name-only", "-r", commit_hash]
    try:
        result = subprocess.run(cmd, cwd=repo_path, text=True, capture_output=True, check=True, errors='replace')
        return result.stdout.splitlines()
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Failed to get changed files: {e}")
        sys.exit(1)

def get_precommit_file(repo_path, commit_hash, file_path):
    """
    Retrieve the content of the file at the parent of the commit (pre-commit version).
    """
    cmd = ["git", "show", f"{commit_hash}^:{file_path}"]
    try:
        result = subprocess.run(cmd, cwd=repo_path, text=True, capture_output=True, check=True, errors='replace')
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Failed to get precommit version of {file_path}: {e}")
        return None

def get_current_file(repo_path, commit_hash, file_path):
    """
    Retrieve the content of the file at the commit (current version).
    """
    cmd = ["git", "show", f"{commit_hash}:{file_path}"]
    try:
        result = subprocess.run(cmd, cwd=repo_path, text=True, capture_output=True, check=True, errors='replace')
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Failed to get current version of {file_path}: {e}")
        return None

# -------------------------------------------------------------------
# Main entry point for updating code blocks in the database

def main():
    repo_path = "/home/azibaeir/Research/Benchmarking/gecko-dev"
    commit_db_path = "/home/azibaeir/Research/Benchmarking/project/vulnerability_dataset/database/database.sqlite"
    
    conn = sqlite3.connect(commit_db_path)
    cursor = conn.cursor()
    cursor.execute("UPDATE vulnerabilities SET VULNERABLE_CODE_BLOCK = '', PATCHED_CODE_BLOCK = '' WHERE PROJECT = 'mozilla'")
    conn.commit()
    
    cursor.execute("SELECT COMMIT_HASH FROM vulnerabilities WHERE PROJECT = 'mozilla'")
    commit_hashes = [row[0] for row in cursor.fetchall()]
    print(f"Processing {len(commit_hashes)} commit(s) in mozilla.")
    
    for commit_hash in commit_hashes:
        print(f"\nProcessing commit: {commit_hash}")
        try:
            patch_content = get_patch(repo_path, commit_hash)
            if patch_content is None:
                print(f"[ERROR] Could not retrieve patch for commit {commit_hash}")
                continue

            functions_in_patch = extract_functions_from_patch(patch_content)
            changed_files = get_changed_files(repo_path, commit_hash)
            if not changed_files:
                print(f"[ERROR] No changed files for commit {commit_hash}")
                continue

            combined_vulnerable_blocks = []
            combined_patched_blocks = []

            for file_path in changed_files:
                print(f"  Processing file: {file_path}")
                pre_content = get_precommit_file(repo_path, commit_hash, file_path)
                curr_content = get_current_file(repo_path, commit_hash, file_path)
                if pre_content is None or curr_content is None:
                    print(f"    [ERROR] Missing content for {file_path}, skipping.")
                    continue

                # Save file contents to temporary files.
                pre_filename = f"{commit_hash}_pre_{os.path.basename(file_path)}"
                with open(pre_filename, 'w', encoding='utf-8') as f:
                    f.write(pre_content)
                curr_filename = f"{commit_hash}_curr_{os.path.basename(file_path)}"
                with open(curr_filename, 'w', encoding='utf-8') as f:
                    f.write(curr_content)
                
                file_vulnerable_blocks = []
                file_patched_blocks = []
                source_extensions = (".c", ".cpp", ".h", ".hpp", ".cc", ".cxx")
                if file_path.lower().endswith(source_extensions):
                    for func_name, class_name in functions_in_patch:
                        if func_name not in pre_content and func_name not in curr_content:
                            continue
                        vuln_func = find_function(pre_content, func_name, class_name, filename=file_path)
                        patch_func = find_function(curr_content, func_name, class_name, filename=file_path)
                        if vuln_func:
                            file_vulnerable_blocks.append(vuln_func)
                        else:
                            print(f"      [ERROR] Vulnerable version not found for {func_name} in {file_path}")
                        if patch_func:
                            file_patched_blocks.append(patch_func)
                        else:
                            print(f"      [ERROR] Patched version not found for {func_name} in {file_path}")
                else:
                    file_vulnerable_blocks.append(pre_content)
                    file_patched_blocks.append(curr_content)
                
                combined_vulnerable_blocks.append(f"// File: {file_path}\n" + "\n\n".join(file_vulnerable_blocks))
                combined_patched_blocks.append(f"// File: {file_path}\n" + "\n\n".join(file_patched_blocks))
                
                # Remove temporary files.
                os.remove(pre_filename)
                os.remove(curr_filename)
            
            vulnerable_code_block = "\n\n".join(combined_vulnerable_blocks)
            patched_code_block = "\n\n".join(combined_patched_blocks)
            
            cursor.execute("""
                UPDATE vulnerabilities
                SET VULNERABLE_CODE_BLOCK = ?,
                    PATCHED_CODE_BLOCK = ?
                WHERE COMMIT_HASH = ? AND PROJECT = 'mozilla'
            """, (vulnerable_code_block, patched_code_block, commit_hash))
            conn.commit()
            print(f"  Updated commit {commit_hash} with new code blocks.")
        except Exception as e:
            print(f"[ERROR] Processing commit {commit_hash} failed: {e}")
    
    cursor.close()
    conn.close()
    print("Processing complete.")

if __name__ == "__main__":
    main()
