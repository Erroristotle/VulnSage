
#!/usr/bin/env python3
import os
import sys
import subprocess
import re
import requests
import platform
import clang.cindex

# -------------------------------------------------------------------
# Configure libclang path based on OS
if platform.system() == "Darwin":
    clang.cindex.Config.set_library_file("/Applications/Xcode.app/Contents/Frameworks/libclang.dylib")
elif platform.system() == "Linux":
    possible_paths = [
        "/usr/lib/llvm-11/lib/libclang.so",
        "/usr/lib/libclang.so",
        "/usr/lib/llvm/lib/libclang.so"
    ]
    for path in possible_paths:
        if os.path.exists(path):
            clang.cindex.Config.set_library_file(path)
            break
# -------------------------------------------------------------------
# Function extraction routines using text-based and Clang-based methods

def find_function(source_code, function_name, class_name=None, filename=None):
    """
    Find a function definition in the given source code using two methods:
      1. Text-based parsing (suitable for many C files)
      2. Clang-based parsing (better for C++ files)
    
    The function first attempts to locate the function using text parsing.
    If that fails, it falls back to a Clang-based approach.
    
    Parameters:
        source_code (str): The source code to search.
        function_name (str): The name of the function to find.
        class_name (str, optional): If searching for a class member, provide the class name.
        filename (str, optional): Filename hint for Clang parsing (default is "temp.cpp").
    
    Returns:
        str or None: The full function definition if found; otherwise, None.
    """
    # --- Text-based parsing ---
    lines = source_code.split('\n')
    for i, line in enumerate(lines):
        if function_name in line and '(' in line and not line.strip().startswith('//'):
            words = line.strip().split()
            if function_name in words or f"{function_name}(" in line:
                print(f"[DEBUG] Found potential function definition (text): {line.strip()}")
                brace_count = 0
                start_line = i
                found_opening = False
                # Try to adjust for multi-line definitions
                while start_line > 0 and not lines[start_line - 1].strip().endswith(';'):
                    start_line -= 1
                    if lines[start_line].strip().startswith('/*') or lines[start_line].strip().startswith('*'):
                        continue
                    if lines[start_line].strip():
                        break
                function_lines = []
                for j in range(start_line, len(lines)):
                    current_line = lines[j]
                    function_lines.append(current_line)
                    for char in current_line:
                        if char == '{':
                            found_opening = True
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                    if found_opening and brace_count == 0:
                        return '\n'.join(function_lines)
    
    # --- Clang-based parsing ---
    import clang.cindex
    index = clang.cindex.Index.create()
    args = [
        "-x", "c++",
        "--std=c++11",
        "-fparse-all-comments",
        "-I/usr/include",
        "-I/usr/local/include",
        "-I.",
        "-DMOZILLA_INTERNAL_API",
        "-DNDEBUG",
        "-DTRIMMED"
    ]
    try:
        tu = index.parse(
            filename or "temp.cpp",
            args=args,
            unsaved_files=[(filename or "temp.cpp", source_code)],
            options=clang.cindex.TranslationUnit.PARSE_SKIP_FUNCTION_BODIES
        )
    except Exception as e:
        print(f"[ERROR] Clang failed to parse {filename}: {e}")
        return None

    if not tu:
        print("[ERROR] Failed to create translation unit")
        return None

    for diag in tu.diagnostics:
        if diag.severity >= clang.cindex.Diagnostic.Warning:
            severity = {2: "Warning", 3: "Error", 4: "Fatal"}.get(diag.severity, "Unknown")
            print(f"[{severity}] {diag.spelling}")

    # Use a simple line search in the source as a fallback after Clang parsing
    for line in source_code.split('\n'):
        if class_name:
            search_pattern = f"{class_name}::{function_name}"
        else:
            words = line.split()
            if function_name in words and '(' in line:
                search_pattern = function_name
            else:
                continue

        if search_pattern in line:
            print(f"[DEBUG] Found potential function definition (clang): {line.strip()}")
            start_idx = source_code.find(line)
            if start_idx != -1:
                brace_count = 0
                end_idx = start_idx
                found_opening = False
                for i in range(start_idx, len(source_code)):
                    if source_code[i] == '{':
                        found_opening = True
                        brace_count += 1
                    elif source_code[i] == '}':
                        brace_count -= 1
                        if found_opening and brace_count == 0:
                            end_idx = i + 1
                            break
                if end_idx > start_idx:
                    return source_code[start_idx:end_idx]
    return None

# -------------------------------------------------------------------
# Extract function names from a patch/diff file.

def extract_functions_from_patch(patch_content):
    """
    Extract all function names from a patch/diff file where changes (+ or -) occurred.
    Returns a list of tuples (function_name, class_name).
    """
    lines = patch_content.split('\n')
    current_function = None
    current_class = None
    in_function = False
    functions = []
    
    for i, line in enumerate(lines):
        stripped_line = line.strip()
        
        # Handle @@ context lines
        if line.startswith('@@'):
            in_function = False
            current_function = None
            current_class = None
            
            if '@@ ' in line:
                context_part = line.split('@@ ')[-1].strip()
                if '::' in context_part:
                    parts = context_part.split('::')
                    current_class = parts[0].strip().replace('@', '').strip()
                    current_function = parts[1].split('(')[0].strip()
                    in_function = True
                else:
                    parts = context_part.split('(')
                    if len(parts) > 1:
                        func_parts = parts[0].split()
                        if func_parts:
                            current_function = func_parts[-1].strip()
                            current_class = None
                            in_function = True

        if not in_function:
            if '::' in stripped_line and '(' in stripped_line and not stripped_line.startswith(('+', '-', '//', '@')):
                parts = stripped_line.split('::')
                if len(parts) == 2:
                    current_class = parts[0].strip()
                    current_function = parts[1].split('(')[0].strip()
                    in_function = True
            elif '(' in stripped_line and not stripped_line.startswith(('+', '-', '//', '@', '}')):
                parts = stripped_line.split('(')[0].strip().split()
                if parts and not parts[0] in ['if', 'while', 'for', 'switch', 'return']:
                    current_function = parts[-1]
                    current_class = None
                    in_function = True
        
        if in_function and line.startswith(('+', '-')) and not line.startswith(('+++ ', '--- ')):
            if current_class and '@' in current_class:
                current_class = current_class.split('@')[-1].strip()
            current = (current_function, current_class)
            if current not in functions:
                functions.append(current)
    print(f"functions: {functions}")
    return functions

# -------------------------------------------------------------------
# Git interaction routines

def get_patch(repo_path, commit_hash):
    """
    Retrieve the full patch (diff) for the given commit.
    """
    cmd = ["git", "show", commit_hash]
    try:
        result = subprocess.run(cmd, cwd=repo_path, text=True, capture_output=True, check=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Failed to get patch for commit {commit_hash}: {e}")
        return None

def get_changed_files(repo_path, commit_hash):
    """
    Use git diff-tree to list all files changed in the given commit.
    """
    cmd = ["git", "diff-tree", "--no-commit-id", "--name-only", "-r", commit_hash]
    try:
        result = subprocess.run(cmd, cwd=repo_path, text=True, capture_output=True, check=True)
        return result.stdout.splitlines()
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Failed to get changed files: {e}")
        sys.exit(1)

def get_precommit_file(repo_path, commit_hash, file_path):
    """
    Retrieve the content of the file at the parent of the commit (pre-commit version).
    """
    cmd = ["git", "show", f"{commit_hash}^:{file_path}"]
    try:
        result = subprocess.run(cmd, cwd=repo_path, text=True, capture_output=True, check=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Failed to get precommit version of {file_path}: {e}")
        return None

def get_current_file(repo_path, commit_hash, file_path):
    """
    Retrieve the content of the file at the commit (current version).
    """
    cmd = ["git", "show", f"{commit_hash}:{file_path}"]
    try:
        result = subprocess.run(cmd, cwd=repo_path, text=True, capture_output=True, check=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Failed to get current version of {file_path}: {e}")
        return None

# -------------------------------------------------------------------
# Main entry point

def main():
    # --- Configuration ---
    repo_path = "/home/azibaeir/Research/Benchmarking/gecko-dev"  # Update as needed.
    commit_hash = "d3fc632669c98bc8a94c820be75455ca4b446cf7"
    # commit_hash = "b59073dc8fae65cd9dc81c0137b0f7a9911873e2"
    # commit_hash = "75b14a0e97e07f63ad55f41b7d978aeba31d711e"
    # commit_hash = "e29d8ab4e4e47c0f84ecd43c9d100791d265f71c"

    if not os.path.isdir(repo_path):
        print(f"[ERROR] Repository path not found: {repo_path}")
        sys.exit(1)

    # Retrieve patch content and extract function names from the patch.
    patch_content = get_patch(repo_path, commit_hash)
    if patch_content is None:
        print("[ERROR] Could not retrieve patch content.")
        return

    print("========== Extracting functions from patch ==========")
    functions_in_patch = extract_functions_from_patch(patch_content)
    if functions_in_patch:
        for func, cls in functions_in_patch:
            if cls:
                print(f"Function: {func}, Class: {cls}")
            else:
                print(f"Function: {func}")
    else:
        print("No functions extracted from patch.")
    print("=====================================================\n")

    # Get list of changed files for this commit.
    changed_files = get_changed_files(repo_path, commit_hash)
    if not changed_files:
        print("No changed files found for this commit.")
        return

    # Prepare accumulators for combined code blocks.
    combined_vulnerable_code = []
    combined_patched_code = []

    # For each changed file, fetch pre-commit and current versions,
    # then extract the complete function definitions for each changed function.
    for file_path in changed_files:
        print(f"Processing file: {file_path}")
        pre_content = get_precommit_file(repo_path, commit_hash, file_path)
        curr_content = get_current_file(repo_path, commit_hash, file_path)
        
        if pre_content is None or curr_content is None:
            print(f"[WARNING] Skipping file {file_path} due to missing content.")
            continue

        # Optionally, save file contents
        pre_filename = f"{commit_hash}_pre_{os.path.basename(file_path)}"
        with open(pre_filename, 'w', encoding='utf-8') as f:
            f.write(pre_content)
        curr_filename = f"{commit_hash}_curr_{os.path.basename(file_path)}"
        with open(curr_filename, 'w', encoding='utf-8') as f:
            f.write(curr_content)

        file_vulnerable_blocks = []
        file_patched_blocks = []

        # For each function extracted from the patch, check if it appears in the file.
        for func_name, class_name in functions_in_patch:
            # Check if the function name is present in at least one version.
            if func_name not in pre_content and func_name not in curr_content:
                continue

            print(f"  Attempting extraction for function '{func_name}'", end="")
            if class_name:
                print(f" (Class: {class_name})")
            else:
                print()

            vulnerable_func = find_function(pre_content, func_name, class_name, filename=file_path)
            patched_func = find_function(curr_content, func_name, class_name, filename=file_path)

            if vulnerable_func:
                file_vulnerable_blocks.append(vulnerable_func)
            else:
                print(f"    [INFO] Vulnerable version of {func_name} not found in {file_path}")

            if patched_func:
                file_patched_blocks.append(patched_func)
            else:
                print(f"    [INFO] Patched version of {func_name} not found in {file_path}")

        # Combine file-level code: if functions were extracted, prepend a file header.
        if file_vulnerable_blocks:
            combined_vulnerable_code.append(f"// File: {file_path}\n" + "\n\n".join(file_vulnerable_blocks))
        else:
            # If no functions, include the whole file as vulnerable code.
            combined_vulnerable_code.append(f"// File: {file_path}\n" + pre_content)

        if file_patched_blocks:
            combined_patched_code.append(f"// File: {file_path}\n" + "\n\n".join(file_patched_blocks))
        else:
            combined_patched_code.append(f"// File: {file_path}\n" + curr_content)

    # Build the final combined code blocks.
    vulnerable_code_block = "\n\n".join(combined_vulnerable_code)
    patched_code_block = "\n\n".join(combined_patched_code)

    print("========== Combined Vulnerable Code Block ==========")
    print(vulnerable_code_block)
    print("=====================================================\n")
    print("========== Combined Patched Code Block ==========")
    print(patched_code_block)
    print("=====================================================")

if __name__ == "__main__":
    main()


# all of the code except code blocks
